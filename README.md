## Отчет по лабораторной работе № 2

#### № группы: `ПМ-2403`

#### Выполнила: `Соколова Анастасия Павловна`

#### Вариант: `21`

### Cодержание:

- [Постановка задачи](#1-постановка-задачи)
- [Входные и выходные данные](#2-входные-и-выходные-данные)
- [Выбор структуры данных](#3-выбор-структуры-данных)
- [Алгоритм](#4-алгоритм)
- [Программа](#5-программа)
- [Анализ правильности решения](#6-анализ-правильности-решения)

### 1. Постановка задачи

> Напишите программу на Java, которая выполняет следующие действия
с двумерным массивом целых чисел:
1. Считывает с консоли размеры массива N и M, затем элементы
массива размером N × M.
2. Находит и выводит количество уникальных чисел в массиве.
3. Переставляет столбцы массива в порядке возрастания суммы их
элементов. Если суммы равны, сравнивает количество уникальных
чисел в столбце.
4. Выводит элементы массива по диагоналям, начиная с верхней левой диагонали (1 элемент) и двигаясь вправо и вниз.
5. Заменяет все числа в массиве на их факториалы и выводит полученный массив

> Программа получает на вход целые числа N и M, которые задают размер массива, а далее набор целых чисел - элементов массива.

Данную задачу можно разделить на подзадачи: 
1. Считывание параметров и элементов с консоли.
2. Поиск уникальных чисел.
3. Подсчет и сравнение суммы элементов и количества уникальных элементов по столбцам и их престановка в порядке возрастания.
4. Выведение элементов массива по диагонали.
5. Вычисление факториала каждого элемента и их выведение упорядоченно в виде массива.

### 2. Входные и выходные данные

#### Данные на вход

На вход программа должна получать 2 целых положительных числа, указывающих размер. Этим задается нижняя граница (число >=1), но верхней не существует (до бесконечности). 
Затем поступает набор целых чисел неограниченной величины, но в количестве, ограниченном ранее размером массива.

|                | Тип         | min значение | max значение |
|----------------|-------------|--------------|--------------|
| N (Число 1)    | Целое число |      1       |     +∞       |
| M (Число 2)    | Целое число |      1       |     +∞       |
| Given (массив) | Целые числа |     -∞       |     +∞       |


#### Данные на выход

У каждой задачи на выход идут разные типы данных:
1. Последовательность уникальных элементов, найденных в массиве.
3. Массивы, изменненые согласно подзадачам.

|                    | Тип                         | min значение | max значение   |
|--------------------|---------------------------- |--------------|----------------|
| Последовательность | Целое неотрицательное число |      -∞      |       +∞       |
| Массив 1           | Массив                      |              |                |
| Массив 2           | Массив                      |              |                |
| ...

### 3. Выбор структуры данных

Программа получает на вход целые числа. Двое из них указывают на размер,поэтому не могут быть отрицательными или равны нулю. Но остальные являются 
набором элементов массива и у них нет ограничений. Можно предположить, что находить факториал слишком больших чисел в крупном массиве будет затруднительно и эта 
программа не предназначена для вычисления масштабных объемов данных, поэтому можно использовать тип целочисленных данных не с макимальным диапазоном. 
Таким образом, все числа будет вполне разумно хранить в виде int. При необходимости в соответствии с потребностями можно легко преобразовать тип данных в long.

|             | название переменной     | Тип (в Java)      | 
|-------------|-------------------------|-------------------|
| N (Число 1) | `n`                     | `int`             |
| M (Число 2) | `m`                     | `int`             | 
| a (массив)  | `Given`                 | `int`(у элементов)| 


Результат представлен в виде массива целых чисел.

|                    | название переменной | Тип (в Java)   | 
|--------------------|---------------------|----------------|
| Mассив             | TransSorted         |                |
| Счетчик            | CountU              |                |
| (Наборы чисел)     |                     |                |


### 4. Алгоритм

#### Алгоритм выполнения программы:

1. **Ввод данных:**  
   Программа считывает целые числа: длину массива N и его высоту M. Далее последовательность целочисленных элементов в указанном NxM размере и заносит их в массив Given.

2. **Уникальный элемент**  
   - Уникальный элемент ищем с помощью перебора и сравнения всех элементов между собой.
   - Сначала перебираем все индексы элементов двумерного массива: высоты и ширины - с помощью двух вложенных циклов.
   - Затем обнуляем "счетчик" k, который означает количество совпадения элементов. 
   - Далее снова перебираем все эелементы и сравниваем их с тем, который выбрали в первом переборе.
   - При наличии совпадения двух выбранных в обеих переборах циклах увеличиваем значение "счетчика" на 1.
   - Каждый элемент совпадет как минимум сам с собой. Если же совпадений больше - он не уникален. Поэтому проверяем количество совпадений и выделяем только те элементы,
которые имеют лишь одно совпадение. Считаем их количество в счетчике CountU (он был иницииирован и обнулен до всех циклов).

3. **Сортировка столбцов**
   - Для удобства (усложнения,как потом выяснилось) подсчета создаем новую матрицу Trans, которая является транспорированной матрицей исходной матрицы Given. Таким образом, столбцы матрицы Given стали строками матрицы Trans.
   - В качестве помощи также создаем матрицу SumTable, которая будет состоять из 2 строк: верхняя содержит сумму столбца, нижняя - номер столбца.
   - На этом же этапе создаем массив UnicCount, который пригодится в решении следующей задачи. Он состоит из двух строк: верхняя содержит количество элементов в столбце, а нижняя номер этого столбца. Заполняем его значениями, найденными по аналогии с процессом поиска уникального элемента в массиве. Только в данном случае ограничиваем область поиска до внутри одной строки.
   - Методом перебора проходим по строкам матрицы Trans, запоминаем номер и считаем сумму элементов каждой строки и количество уникальных элементов.
   - Результаты подсета суммы вносим в верхнюю строку матрицы SumTable, а зафиксированный номер строки - в нижнюю строку. Аналагично для UnicCount.
   - Сортируем матрицы UnicCount и SumTable по значению верхней строки в порядке возрастания, используя сортировку "пузырьком". Сравниваем каждые соседние элементы и меняем местами так, чтобы больший из них был правее. При встрече двух одинаковых значений сравниваем соответствующие строки по количеству уникальных элементов, информация о которых хранится в массиве UnicCount. С учетом двух условий продолжаем сортировку.
   - Отсортированный массив заносим в массив Sorted, транспонируем его в матрицу TransSorted и выводим на экран.
     
4. **Вывод матрицы по диагоналям**
   - Причечательно, что сумма координат элементов в каждой диагонали равна. Минимальная сумма индексов принадлежит первому элементу (0;0) и равна нулю. Максимальная - у последнего элемента (n-1;m-1) и равна m+n-2
   - Перебираем суммы элементов от минимального (0) до максимальной (n+m-2)
   - Перебираем числа от 0 в этом диапазоне и составляем из них пары индексов от наименьшего к большему.
   - Выводим на экран последовательность чисел согласно полученным индексам построчно.
     
5. **Поиск факториала**
   - Создаем подпрограмму, которая считает факториал числа с помощью рекурсии. На каждом проходе цикла уменьшаем значение переменной, задаваемой в метод, и умножаем на число. Таким образом, метод перемножает все числа от 1 до данного.
   - Применяем созданный метод к каждому элементу и выводим на экран.
   

#### Формулы

1. Для вывода массива по диагоналям я использовала закономерность: в каждой диагонали сумма координат равна.
2. Рекурсия в подпрограмме вычисления факториала основывается на формуле подсчета факториала числа: N! = 1*2*...*N


### 5. Программа

```java
import java.io.PrintStream;
import java.util.Scanner;
public class Main {
    public static Scanner in = new Scanner(System.in);
    public static PrintStream out = System.out;

    public static void main(String[] args) {
        // вводим размерность массива
        int n = in.nextInt();
        int m = in.nextInt();
        // создаем массив согласно введенным размерам
        int[][] Given = new int[n][m];
        // считываем элементы и заносим в массив
        for (int i = 0; i < Given.length; i++) {
            for (int j = 0; j < Given[i].length; j++)
                Given[i][j] = in.nextInt();
        }

        int CountU = 0;                                         //счетчик уникальных элементов в матрице
        for (int i = 0; i < Given.length; i++) {
            for (int j = 0; j < Given[i].length; j++) {         //рассматриваем каждый элемент матрицы
                int k = 0;                                      //счетчик количества рассматриваемого элемента в матрице
                for (int q = 0; q < Given.length; q++) {
                    for (int p = 0; p < Given[i].length; p++) { //перебираем каждый элемент матрицы
                        if (Given[i][j] == Given[q][p]) {       //если элемент равен рассматриваемому
                            k += 1;                             //то значит, что таких эелементов на 1 больше, чем было
                        }
                    }
                }
                if (k == 1) {                                   //если рассматриваемых элементов в матрице 1
                    CountU += 1;                                //то увеличиваем счетчик уникальных элементов в матрице
                }
            }
        }
        out.print("Количествово уникальных элементов: ");
        out.println(CountU);

        //создаем и печатаем для проверки транспорированный массив
        //out.print("Транспорированный массив");
        out.println();
        int[][] Trans = new int[m][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                Trans[j][i] = Given[i][j];                      //меняем местами индексы строки и столбца
            }
        }
        //for (int i = 0; i < Trans.length; i++) {
        //    for (int j = 0; j < Trans[i].length; j++)
        //        out.print(Trans[i][j] + " ");
        //    out.println();
        //}

        //создаем массив для соединения результатов подсчета количества уникальных элементов с номером соответствующей строки
        int[][] UnicCount = new int[2][m];
        for (int i = 0; i < Trans.length; i++) {            //берем строку i
            CountU = 0;                                     //начальное значение кол-ва уникальных элементов в ней
            for (int j = 0; j < Trans[i].length; j++) {     //рассматриваем каждый элемент строки i
                int k = 0;                                  //начальное значение кол-ва этого элемента в строке
                for (int p = 0; p < Trans[i].length; p++) { //перебираем каждый элемент строки
                    if (Trans[i][j] == Trans[i][p]) {       //если они равны
                        k += 1;                             //увеличиваем счетчик
                    }
                }
                if (k == 1) {                               //если рассматриваемого элемента 1
                    CountU += 1;                            //увеличиваем кол-ва уникальных элементов в строке
                }
            }
            UnicCount[0][i] = CountU;                       //после рассмотрения каждого элемента строки записываем
            UnicCount[1][i] = i;                            //полученное колво в массив и после берем следующую строку
        }

        //for (int i = 0; i < UnicCount.length; i++) {
        //    for (int j = 0; j < UnicCount[i].length; j++)
        //        out.print(UnicCount[i][j] + " ");
        //    out.println();
        //}

        //создаем массив для соединение результатов подсчета суммы строк и соответствующего номера и печатаем его для проверки
        //out.println("Матрица для сортировки");
        int[][] SumTable = new int[2][m];
        for (int i = 0; i < Trans.length; i++) {
            int sum = 0;                                            //обнуляем начальное значение суммы для каждой новой строки
            for (int j = 0; j < Trans[i].length; j++) {
                sum += Trans[i][j];                                 //суммируем каждый элемент строки поочередно
            }
            SumTable[0][i] = sum;
            SumTable[1][i] = i;
        }
        //for (int i = 0; i < SumTable.length; i++) {
        //    for (int j = 0; j < SumTable[i].length; j++)
        //        out.print(SumTable[i][j] + " ");
        //    out.println();
        //}

        //сортируем массив количества уникальных чисел столбца
        for (int i = 1; i < m; i++) {
            for (int j = 0; j < m - i; j++) {
                if (UnicCount[0][j] > UnicCount[0][j + 1]) {
                    int w = UnicCount[0][j];
                    int z = UnicCount[1][j];
                    UnicCount[0][j] = UnicCount[0][j + 1];
                    UnicCount[1][j] = UnicCount[1][j + 1];
                    UnicCount[0][j + 1] = w;
                    UnicCount[1][j + 1] = z;
                }

                }
            }
        //out.println();
        //for (int i = 0; i < UnicCount.length; i++) {
        //    for (int j = 0; j < UnicCount[i].length; j++)
        //        out.print(UnicCount[i][j] + " ");
        //    out.println();
        //}
        //out.println();

        //сортируем массив SumTable по возрастанию элементов верхней строки с учетом массива UnicCount
        for (int i = 1; i < m; i++) {
            for (int j = 0; j < m - i; j++) {
                if (SumTable[0][j] > SumTable[0][j + 1]) {
                    int x = SumTable[0][j];
                    int y = SumTable[1][j];
                    SumTable[0][j] = SumTable[0][j + 1];
                    SumTable[1][j] = SumTable[1][j + 1];
                    SumTable[0][j + 1] = x;
                    SumTable[1][j + 1] = y;
                }
                if(SumTable[0][j] == SumTable[0][j + 1]) {
                    if (UnicCount[0][j] > UnicCount[0][j + 1]) {
                        int x = SumTable[0][j];
                        int y = SumTable[1][j];
                        SumTable[0][j] = SumTable[0][j + 1];
                        SumTable[1][j] = SumTable[1][j + 1];
                        SumTable[0][j + 1] = x;
                        SumTable[1][j + 1] = y;
                    }
                }
            }
        }
        //for (int i = 0; i < SumTable.length; i++) {
        //    for (int j = 0; j < SumTable[i].length; j++)
        //        out.print(SumTable[i][j] + " ");
        //    out.println();}
        //    out.println();

        //создаем массив, в котором выведем результат
        int[][] Sorted = new int[m][n];
        //выводим строки по очереди значений, полученных в результате сортировки выше. очередность хранится в нижней строке массива SumTable
        for (int i = 0; i < m; i++)
            Sorted[i] = Trans[SumTable[1][i]];

        //Транспонируем его, т.к. использовали перевернутую матрицу в основе
        int[][] TransSorted = new int[n][m];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                TransSorted[j][i] = Sorted[i][j];                      //меняем местами индексы строки и столбца
            }
        }

        //печатаем отсортированный массив
        out.println("Отсортированный массив");
        for (int i = 0; i < TransSorted.length; i++) {
            for (int j = 0; j < TransSorted[i].length; j++)
                out.print(TransSorted[i][j] + " ");
            out.println();
        }
        //Переходим к следующей задаче о выводе диагоналей
        out.println("По диагоналям");
        for (int k = 0; k <= m + n - 2; k++) {
            for (int j = 0; j <= k; j++) {
                int i = k - j;
                if (i < n && j < m) {
                    System.out.print(Given[i][j] + " ");
                }
            }
            System.out.println();
        }

        // Задача о вычислении факториала каждого элемента: Проходим по каждому элементу, ищем факториал с помощью метода, присваеваем новое значение и выводим матрицу на экран
        for (int i = 0; i < Given.length; i++)
            for (int j = 0; j < Given[i].length; j++)
                Given[i][j] = factorial(Given[i][j]);
        out.println("Массив факториалов");
        for (int i = 0; i < Given.length; i++) {
            for (int j = 0; j < Given[i].length; j++)
                out.print(Given[i][j] + " ");
            out.println();
        }
    }

    // с помощью рекурсии вычисляем факториал числа, умножая данное число на факториал числа перед ним => перемножаем числа от 1 до а
    public static int factorial(int a) {
        if (a <= 1)
            return 1;
        else
            return a * factorial(a - 1);
    }
}

```

### 6. Анализ правильности решения



1. Тест на отсутствие уникальных элементов в массиве

    - **Input**:
        ```
2
4
1 2 3 1
3 2 2 1
        ```

    - **Output**:
        ```
Количествово уникальных элементов: 0

Отсортированный массив
1 1 2 3 
1 3 2 2 
По диагоналям
1 
3 2 
2 3 
2 1 
1 
Массив факториалов
1 2 6 1 
6 2 2 1       
        ```

2. Тест на подсчет уникальных чисел в массиве

    - **Input**:
        ```
2
5
5 6 8 3 1
8 3 3 5 7       
        ```

    - **Output**:
        ```
Количествово уникальных элементов: 3

Отсортированный массив
3 1 6 8 5 
5 7 3 3 8 
По диагоналям
5 
8 6 
3 8 
3 3 
5 1 
7 
Массив факториалов
120 720 40320 6 1 
40320 6 6 120 5040 

        ```

3. Тест на вывод по диагоналям не только прямоугольной, но и квадратной матрицы

    - **Input**:
        ```
3
3
1 2 3
2 3 4
3 4 5      
        ```

    - **Output**:
        ```
Количествово уникальных элементов: 2

Отсортированный массив
1 2 3 
2 3 4 
3 4 5 
По диагоналям
1 
2 2 
3 3 3 
4 4 
5 
Массив факториалов
1 2 6 
2 6 24 
6 24 120 
        
        ```

4. Тест на корректность вычисления факториалов

    - **Input**:
        ```
1
3
0 2 4        
        ```

    - **Output**:
        ```
Количествово уникальных элементов: 3

Отсортированный массив
0 2 4 
По диагоналям
0 
2 
4 
Массив факториалов
1 2 24 
        ```

5. Тест на сортировку по сумме элементов 

    - **Input**:
        ```
2
3
1 2 1
4 2 1
  
        ```

    - **Output**:
        ```
Количествово уникальных элементов: 1

Отсортированный массив
1 2 1 
1 2 4 
По диагоналям
1 
4 2 
2 1 
1 
Массив факториалов
1 2 1 
24 2 1    
        ```
 6. Тест на сортировку с учетом не только суммы, но и количества уникальных элементов в столбце (не успешно)

    - **Input**:
        ```
2
4
1 2 3 1
3 2 2 1     
        ```

    - **Output**:
        ```
Количествово уникальных элементов: 0

Отсортированный массив    (Ожидалось:
1 1 2 3                     1 2 1 3
1 3 2 2                     1 2 3 2)
По диагоналям
1 
3 2 
2 3 
2 1 
1 
Массив факториалов
1 2 6 1 
6 2 2 1 

        ```
        
